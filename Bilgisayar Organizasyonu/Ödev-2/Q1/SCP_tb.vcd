$date
	Tue Apr 30 19:56:12 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module SCP_tb $end
$var reg 1 ! clk $end
$var reg 1 " rst $end
$scope module scp $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 1 # zero $end
$var wire 32 $ srcB [31:0] $end
$var wire 2 % resultSrc [1:0] $end
$var wire 32 & result [31:0] $end
$var wire 1 ' regWrite $end
$var wire 32 ( readData [31:0] $end
$var wire 1 ) memWrite $end
$var wire 32 * instruction [31:0] $end
$var wire 2 + immSrc [1:0] $end
$var wire 32 , immExt [31:0] $end
$var wire 32 - RD2 [31:0] $end
$var wire 32 . RD1 [31:0] $end
$var wire 32 / PCTarget [31:0] $end
$var wire 1 0 PCSrc $end
$var wire 32 1 PCPlus4 [31:0] $end
$var wire 32 2 PCNext [31:0] $end
$var wire 32 3 PC [31:0] $end
$var wire 1 4 ALUSrc $end
$var wire 32 5 ALUResult [31:0] $end
$var wire 3 6 ALUControl [2:0] $end
$scope module PCAdder $end
$var wire 32 7 B [31:0] $end
$var wire 32 8 result [31:0] $end
$var wire 32 9 A [31:0] $end
$upscope $end
$scope module alu $end
$var wire 1 # zero $end
$var wire 32 : sum [31:0] $end
$var wire 32 ; result [31:0] $end
$var wire 32 < B [31:0] $end
$var wire 3 = ALUControl [2:0] $end
$var wire 32 > A [31:0] $end
$upscope $end
$scope module control $end
$var wire 1 0 PCSrc $end
$var wire 3 ? funct3 [2:0] $end
$var wire 7 @ funct7 [6:0] $end
$var wire 7 A op [6:0] $end
$var wire 1 # zero $end
$var wire 2 B resultSrc [1:0] $end
$var wire 1 ' regWrite $end
$var wire 1 ) memWrite $end
$var wire 1 C jump $end
$var wire 2 D immSrc [1:0] $end
$var wire 1 E branch $end
$var wire 1 4 ALUSrc $end
$var wire 2 F ALUOp [1:0] $end
$var wire 3 G ALUControl [2:0] $end
$scope module ALUDecoder $end
$var wire 3 H funct3 [2:0] $end
$var wire 7 I funct7 [6:0] $end
$var wire 7 J op [6:0] $end
$var wire 2 K ALUOp [1:0] $end
$var wire 3 L ALUControl [2:0] $end
$upscope $end
$scope module mainDecoder $end
$var wire 7 M op [6:0] $end
$var wire 2 N resultSrc [1:0] $end
$var wire 1 ' regWrite $end
$var wire 1 ) memWrite $end
$var wire 1 C jump $end
$var wire 2 O immSrc [1:0] $end
$var wire 1 E branch $end
$var wire 1 4 ALUSrc $end
$var wire 2 P ALUOp [1:0] $end
$upscope $end
$upscope $end
$scope module dataMem $end
$var wire 32 Q A [31:0] $end
$var wire 1 ) WE $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 R WD [31:0] $end
$var wire 32 S RD [31:0] $end
$upscope $end
$scope module instrMem $end
$var wire 1 " rst $end
$var wire 32 T RD [31:0] $end
$var wire 32 U A [31:0] $end
$upscope $end
$scope module jumpAdder $end
$var wire 32 V result [31:0] $end
$var wire 32 W B [31:0] $end
$var wire 32 X A [31:0] $end
$upscope $end
$scope module muxDatatoReg1 $end
$var wire 32 Y A [31:0] $end
$var wire 32 Z B [31:0] $end
$var wire 32 [ C [31:0] $end
$var wire 32 \ D [31:0] $end
$var wire 2 ] select [1:0] $end
$var wire 32 ^ result [31:0] $end
$upscope $end
$scope module muxRegtoALU $end
$var wire 1 4 select $end
$var wire 32 _ result [31:0] $end
$var wire 32 ` B [31:0] $end
$var wire 32 a A [31:0] $end
$upscope $end
$scope module nextPC $end
$var wire 32 b A [31:0] $end
$var wire 32 c B [31:0] $end
$var wire 1 0 select $end
$var wire 32 d result [31:0] $end
$upscope $end
$scope module pc $end
$var wire 32 e PCNext [31:0] $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var reg 32 f PC [31:0] $end
$upscope $end
$scope module regF $end
$var wire 5 g A1 [4:0] $end
$var wire 5 h A2 [4:0] $end
$var wire 5 i A3 [4:0] $end
$var wire 32 j WD3 [31:0] $end
$var wire 1 ' WE3 $end
$var wire 1 ! clk $end
$var wire 1 " rst $end
$var wire 32 k RD2 [31:0] $end
$var wire 32 l RD1 [31:0] $end
$var integer 32 m i [31:0] $end
$upscope $end
$scope module signExt $end
$var wire 2 n immSrc [1:0] $end
$var wire 32 o instruction [31:0] $end
$var wire 32 p immExt [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b1010 p
b101000000000000010010011 o
b0 n
b100000 m
b0 l
b0 k
b1010 j
b1 i
b1010 h
b0 g
b0 f
b100 e
b100 d
b1010 c
b100 b
b0 a
b1010 `
b1010 _
b1010 ^
b0 ]
bx \
b100 [
bx Z
b1010 Y
b0 X
b1010 W
b1010 V
b0 U
b101000000000000010010011 T
bx S
b0 R
b1010 Q
b10 P
b0 O
b0 N
b10011 M
b0 L
b10 K
b10011 J
b0 I
b0 H
b0 G
b10 F
0E
b0 D
0C
b0 B
b10011 A
b0 @
b0 ?
b0 >
b0 =
b1010 <
b1010 ;
b1010 :
b0 9
b100 8
b100 7
b0 6
b1010 5
14
b0 3
b100 2
b100 1
00
b1010 /
b0 .
b0 -
b1010 ,
b0 +
b101000000000000010010011 *
0)
bx (
1'
b1010 &
b0 %
b1010 $
0#
0"
0!
$end
#5
b1101 &
b1101 ^
b1101 j
b1101 5
b1101 ;
b1101 Q
b1101 Y
b11 $
b11 <
b11 _
b1101 :
b11 ,
b11 W
b11 `
b11 p
b1010 .
b1010 >
b1010 l
b11 h
b1 g
b1100001000000010010011 *
b1100001000000010010011 T
b1100001000000010010011 o
b1000 2
b1000 d
b1000 e
b111 /
b111 V
b111 c
b1000 1
b1000 8
b1000 [
b1000 b
b100 3
b100 9
b100 U
b100 X
b100 f
1!
#10
0!
#15
1'
b1101 $
b1101 <
b1101 _
bx +
bx D
bx O
bx n
04
b11010 &
b11010 ^
b11010 j
b0x000x0000000000x ,
b0x000x0000000000x W
b0x000x0000000000x `
b0x000x0000000000x p
b1101 -
b1101 R
b1101 a
b1101 k
b11010 5
b11010 ;
b11010 Q
b11010 Y
b110011 A
b110011 J
b110011 M
b1 h
b11010 :
b100001000000010110011 *
b100001000000010110011 T
b100001000000010110011 o
b1100 2
b1100 d
b1100 e
b1101 .
b1101 >
b1101 l
bx /
bx V
bx c
b1100 1
b1100 8
b1100 [
b1100 b
b1000 3
b1000 9
b1000 U
b1000 X
b1000 f
1!
#20
0!
#25
x'
bx 6
bx =
bx G
bx L
x#
bx &
bx ^
bx j
x4
bx %
bx B
bx N
bx ]
bx F
bx K
bx P
x0
bx 5
bx ;
bx Q
bx Y
bx ,
bx W
bx `
bx p
x)
xE
xC
bx :
bx $
bx <
bx _
bx @
bx I
bx ?
bx H
bx A
bx J
bx M
bx i
bx h
bx g
bx .
bx >
bx l
bx -
bx R
bx a
bx k
bx *
bx T
bx o
bx 2
bx d
bx e
b10000 1
b10000 8
b10000 [
b10000 b
b1100 3
b1100 9
b1100 U
b1100 X
b1100 f
1!
#30
0!
#35
bx 1
bx 8
bx [
bx b
bx 3
bx 9
bx U
bx X
bx f
1!
#40
0!
#45
1!
#50
0!
#55
1!
#60
0!
#65
1!
#70
0!
#75
1!
#80
0!
#85
1!
#90
0!
#95
1!
#100
0!
#105
1!
#110
0!
#115
1!
#120
0!
#125
1!
#130
0!
#135
1!
#140
0!
#145
1!
#150
0!
#155
1!
#160
0!
#165
1!
#170
0!
#175
0'
b0 :
00
b0 $
b0 <
b0 _
b0 ,
b0 W
b0 `
b0 p
0)
0E
0C
b0 @
b0 I
b0 ?
b0 H
b0 A
b0 J
b0 M
b0 i
b0 h
b0 g
b0 .
b0 >
b0 l
b0 -
b0 R
b0 a
b0 k
b0 (
b0 S
b0 Z
b0 *
b0 T
b0 o
1"
1!
#180
0!
